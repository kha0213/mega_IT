--SEQUENCE : 순차번호 자동 생성 객체 (PRIMARY KEY에서 순차번호 생성이 필요할 때)
--친구이름, 전화번호(NULL), 최종수정일(PRIMARY키가 없으니 만들자)
-- 1 홍길동 010-9999-9999 19/12/30
-- 2 김길동 NULL 19/12/03

CREATE SEQUENCE FRIEND_SEQno; --1,2,3,4,5....

CREATE SEQUENCE FRIEND_SEQno
    START WITH 1000; -- 1000부터 시작 1000,1001,1002...

DROP TABLE FRIEND;
DROP SEQUENCE FRIEND_SEQno;

CREATE SEQUENCE FRIEND_SEQno
    INCREMENT BY 1 --1씩 증가 10이면 10씩증가
    START WITH 1 --1부터
    MAXVALUE 9999 --최대 9999까지
    NOCYCLE; --최대 9999가 되면 끝
    --NOCACHE 캐쉬 없음
    
    
CREATE TABLE FRIEND(
    NUM NUMBER(4) PRIMARY KEY, --순차번호
    NAME VARCHAR2(50),         --친구이름
    TEL VARCHAR2(30) UNIQUE, --유니크는 NULL 가능
    LAST_MODIFIED DATE DEFAULT SYSDATE);  --최종수정일
    
INSERT INTO FRIEND (NUM,NAME,TEL) VALUES 
                   (FRIEND_SEQno.NEXTVAL,'홍길동','010-9999-9999');
INSERT INTO FRIEND (NUM,NAME) VALUES 
                   (FRIEND_SEQno.NEXTVAL,'힝길동');
SELECT * FROM FRIEND;

SELECT FRIEND_SEQno.CURRVAL FROM DUAL; --현재 시퀀스 값
CREATE SEQUENCE FRIEND_SEQno
    MAXVALUE 9999
    NOCYCLE
    NOCACHE;
    

    
CREATE SEQUENCE FRIEND_SEQno
    INCREMENT BY 1 --1씩 증가 10이면 10씩증가
    START WITH 1000 --1000부터
    MAXVALUE 9999 --최대 9999까지
    NOCYCLE --최대 9999가 되면 끝
    NOCACHE;
    
DROP TABLE CUSTOMER;
DROP TABLE CUS_LEVEL;
DROP SEQUENCE CUS_LEVEL_CNO;


CREATE SEQUENCE CUS_LEVEL_CNO
    MAXVALUE 9999
    NOCYCLE
    NOCACHE;

CREATE TABLE CUS_LEVEL(
   LEVELNO NUMBER(2) PRIMARY KEY,
   LEVELNAME VARCHAR2(10) NOT NULL );

INSERT INTO CUS_LEVEL VALUES(1,'VVIP');
INSERT INTO CUS_LEVEL VALUES(2,'VIP');
INSERT INTO CUS_LEVEL VALUES(3,'NORMAL');
INSERT INTO CUS_LEVEL VALUES(4,'BLACK');
   
SELECT * FROM CUS_LEVEL;
   
CREATE TABLE CUSTOMER(
    CNO NUMBER(4) PRIMARY KEY,
    CNAME VARCHAR2(20),
    JOINDATE DATE DEFAULT SYSDATE,
    PHONE VARCHAR2(15) UNIQUE,
    POINT NUMBER(7),
    LEVELNO NUMBER(2) REFERENCES CUS_LEVEL(LEVELNO) );

SELECT * FROM CUSTOMER;
    
INSERT INTO CUSTOMER (CNO, CNAME, JOINDATE, PHONE, POINT, LEVELNO)
    VALUES (CUS_LEVEL_CNO.NEXTVAL, '홍길동', TO_DATE('20171017','YYMMDD'), '010-9999-9999',300,1);
INSERT INTO CUSTOMER (CNO, CNAME, JOINDATE, PHONE, POINT, LEVELNO)
    VALUES (CUS_LEVEL_CNO.NEXTVAL, '이철수', TO_DATE('20160906','YYMMDD'), '010-9999-9888',NULL,2);
INSERT INTO CUSTOMER (CNO, CNAME, JOINDATE, PHONE, POINT, LEVELNO)
    VALUES (CUS_LEVEL_CNO.NEXTVAL, '홍길순', TO_DATE('20160907','YYYYMMDD'), '010-9999-7777',50,3);




SELECT CNO,CNAME,TO_CHAR(JOINDATE,'YYYY-MM-DD') "JOINDATE",PHONE,NVL(POINT,0) "POINT",LEVELNAME FROM CUSTOMER C, CUS_LEVEL L
    WHERE C.LEVELNO=L.LEVELNO;



    
    
--VIEW (가상의 테이블)
CREATE OR REPLACE VIEW EMPv0
    AS SELECT EMPNO, ENAME, JOB,DEPTNO FROM EMP; --만들거나 대체하거나 VIEW만 가능 단순뷰임
CREATE OR REPLACE VIEW EMPv0
    AS SELECT EMPNO, ENAME,SAL*12 "연봉", JOB,DEPTNO FROM EMP; --필드 이름에 특수문자 있으면 안됨!! 엘리야스 해주자
    
SELECT * FROM EMPv0;
    
--복합 뷰 (2개 이상의 테이블로 만든 뷰)
CREATE OR REPLACE VIEW EMPv0
    AS SELECT EMPNO,ENAME,JOB,DNAME FROM EMP E, DEPT D
        WHERE E.DEPTNO=D.DEPTNO;

--부서번호가 30번 부서 직원들만 EMPv1 뷰 생성
CREATE OR REPLACE VIEW EMPv1
    AS SELECT * FROM EMP
    WHERE DEPTNO=30;  --권한까지 조절해야함
SELECT * FROM EMPv1;
INSERT INTO EMPv1 VALUES (1111,'HONG',NULL,NULL,SYSDATE,NULL,NULL,40); --EMP부서에 들어감 이런짓 ㄴㄴ
SELECT * FROM EMP;
DELETE FROM EMP WHERE ENAME='HONG';
    
CREATE OR REPLACE VIEW EMPv1
    AS SELECT * FROM EMP
        WHERE DEPTNO=30
        WITH CHECK OPTION; --30번 부서의 직원만 WRITE/READ가능
INSERT INTO EMPv1 VALUES (1112,'홍',NULL,NULL,SYSDATE,NULL,NULL,40);  --X 체크옵션 때문에      
INSERT INTO EMPv1 VALUES (1112,'홍',NULL,NULL,SYSDATE,NULL,NULL,30);  -- 가능~

CREATE OR REPLACE VIEW EMPv2
    AS SELECT * FROM EMP
    WHERE DEPTNO=30 WITH READ ONLY; --READ ONLY 읽을 수만 있음

INSERT INTO EMPv2 VALUES (1113,'홍',NULL,NULL,NULL,NULL,NULL,30); --READ ONLY라 안됨

-- INSERT 불가한 경우
CREATE OR REPLACE VIEW EMPv3
    AS SELECT ENAME, SAL, COMM FROM EMP;
SELECT * FROM EMPv3;

INSERT INTO EMPv3 VALUES('HONG',9000,5000); --나머지데이터 NULL이 들어가지만 EMPNO에 NULL이 못들어가기때문에 실행이 안됨
CREATE OR REPLACE VIEW SALv1
    AS SELECT EMPNO, ENAME, SAL*12 "YEARSAL" FROM EMP WHERE DEPTNO=10;
SELECT * FROM SALv1;

CREATE OR REPLACE VIEW SALv1 (ID,NAME,YEARSAL)
    AS SELECT EMPNO, ENAME, SAL*12 FROM EMP WHERE DEPTNO=10;

INSERT INTO SALv1 VALUES (119,'홍', 12000); --SAL*12 함수가 필드면 인서트 불가능!!!!!!!!!!!!!

CREATE OR REPLACE VIEW DEPTv1
    AS SELECT DEPTNO, MIN(SAL) MINSAL, MAX(SAL) MAXSAL, AVG(SAL)AVGSAL FROM EMP GROUP BY DEPTNO; --인서트 안됨
SELECT * FROM DEPTv1;
CREATE OR REPLACE VIEW JOBLIST
    AS SELECT DISTINCT JOB, DEPTNO FROM EMP; --INSERT 안됨
    
--?	VIEW에서 DML 연산 수행
--?	단순 VIEW에서 DML 연산을 수행할 수 있다
--?	VIEW가 다음을 포함한다면 행을 제거하거나 수정하거나 추가할 수 없다
--?	그룹함수
--?	GROUP BY 절
--?	DISTINCT 키워드

--INLINE VIEW : FROM절에 SUBQUARY가 옴
--급여가 2000을 초과하는 사원의 평균 급여 출력
SELECT AVG(SAL) FROM (SELECT SAL FROM EMP WHERE SAL>2000);
--이름, 급여, 부서번호, 해당사원의 부서평균급여 옛날것
SELECT ENAME, SAL, DEPTNO, (SELECT AVG(SAL) FROM EMP WHERE E.DEPTNO=DEPTNO)
    FROM EMP E;
--각 부서에서 부서평균급여보다 높은 사원의 이름,급여,부서번호,부서급여평균 출력

DELETE FROM EMP WHERE DEPTNO=40;

SELECT E.ENAME, E.SAL, E.DEPTNO, S.AVGSAL FROM EMP E, (SELECT DEPTNO, AVG(SAL) AVGSAL 
    FROM EMP GROUP BY DEPTNO) S
    WHERE S.DEPTNO=E.DEPTNO;

--이름, 급여, 부서번호, 부서평균급여 (부서평균보다 SAL 많이 받는 사원만 출력)
SELECT E.ENAME, E.SAL, E.DEPTNO, S.AVGSAL FROM EMP E,(SELECT DEPTNO,AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO) S
    WHERE S.DEPTNO=E.DEPTNO AND S.AVGSAL<E.SAL;

SELECT ROWNUM,ENAME,SAL FROM EMP; --EMP테이블에서 가져온 순서

--SAL 등수, ENAME, SAL
SELECT SAL FROM EMP ORDER BY SAL;


-- TOP 1~5
SELECT ROWNUM,ENAME,SAL FROM (SELECT * FROM EMP ORDER BY SAL)
    WHERE ROWNUM<6; --등수대로 정리


SELECT ROWNUM,ENAME,SAL FROM (SELECT * FROM EMP ORDER BY SAL)
    WHERE ROWNUM BETWEEN 1 AND 10; --이건 안뿌려짐
    
SELECT RANK() OVER(ORDER BY SAL) RANK, --똑같지만 5등까지 뿌려라 그건 힘듬
     DENSE_RANK() OVER(ORDER BY SAL) D_RANK,
     ROW_NUMBER() OVER(ORDER BY SAL) R_RANK, ENAME, SAL FROM EMP;

SELECT ROWNUM,RN, ENAME, SAL FROM (SELECT ROWNUM RN, ENAME,SAL FROM 
                                    (SELECT * FROM EMP ORDER BY SAL) A)
        WHERE RN BETWEEN 6 AND 10;
        



--1. 부서명과 사원명을 출력하는 DNAME_ENAME_VU 를 작성하시오
CREATE OR REPLACE VIEW DNAME_ENAME_VU 
    AS SELECT DNAME, ENAME FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO; 
SELECT * FROM DNAME_ENAME_VU;


--2	사원명과 직속상관명을 출력하는 WORKER_MANAGER_VU를 작성하시오
CREATE OR REPLACE VIEW WORKER_MANAGER_VU
    AS SELECT W.ENAME W_ENAME, M.ENAME M_ENAME FROM EMP W, EMP M WHERE W.MGR=M.EMPNO; 

SELECT * FROM WORKER_MANAGER_VU;
DROP VIEW WORKER_MANAGER_VU;

--3. 부서별 급여합계 등수를 출력하시오(부서번호, 급여합계, 등수) ? 친구출제

SELECT RN, DEPTNO, SUMSAL FROM (SELECT ROWNUM RN, DEPTNO, SUMSAL 
                                    FROM (SELECT DEPTNO, SUM(SAL) SUMSAL FROM EMP GROUP BY DEPTNO ORDER BY SUMSAL DESC))
                        WHERE RN BETWEEN 2 AND 3;
SELECT ROWNUM RN, DEPTNO, SUMSAL FROM (SELECT DEPTNO, SUM(SAL) SUMSAL FROM EMP GROUP BY DEPTNO ORDER BY SUMSAL DESC); --서브쿼리
SELECT DEPTNO, SUM(SAL) SUMSAL FROM EMP GROUP BY DEPTNO ORDER BY SUM(SAL) DESC; --서브서브쿼리

--4	사원테이블에서 사번, 사원명, 입사일을 입사일이 최신에서 오래된 사원 순으로 정렬하시오
SELECT EMPNO,ENAME,HIREDATE FROM EMP ORDER BY HIREDATE DESC;
--5	사원테이블에서 사번, 사원명, 입사일을 입사일이 최신에서 오래된 사원 5명을 출력하시오
SELECT ROWNUM,EMPNO,ENAME,HIREDATE FROM (SELECT EMPNO,ENAME,HIREDATE FROM EMP ORDER BY HIREDATE DESC)
    WHERE ROWNUM<6;

--6	사원 테이블에서 사번, 사원명, 입사일을 입사일이 최신에서 오래된 순으로 6번째로 늦은 사원부터 10번째 사원까지 출력
SELECT RN,EMPNO,ENAME,HIREDATE FROM (SELECT ROWNUM RN,EMPNO,ENAME,HIREDATE 
                                            FROM (SELECT EMPNO,ENAME,HIREDATE FROM EMP ORDER BY HIREDATE DESC))
                                WHERE RN BETWEEN 6 AND 10;

